from __future__ import annotations

import array

from typing import Any, Union, List, Iterator, Dict, overload


class BitMap:
    def __init__(self,
                 values: Any = None,
                 copy_on_write: bool = False,
                 optimize: bool = True,
                 no_init: bool = False) -> None: ...

    def __contains__(self, other: int) -> bool: ...
    def to_array(self) -> array.array[int]: ...
    def min(self) -> int: ...
    def max(self) -> int: ...
    def add(self, value: int) -> None: ...
    def add_checked(self, value: int) -> None: ...
    def add_range(self, start: int, end: int) -> None: ...
    def clear(self) -> None: ...
    def difference_update(self, *others: Union[BitMap, List[int]]) -> None: ...
    def discard(self, value: int) -> None: ...
    def flip_inplace(self, start: int, stop: int) -> None: ...
    def intersection_update(self, *others: Union[BitMap, List[int]]) -> None: ...
    def overwrite(self, other: BitMap) -> None: ...
    def pop(self) -> int: ...
    def remove(self, value: int) -> None: ...
    def remove_range(self, start: int, stop: int) -> None: ...
    def symmetric_difference(self, other: BitMap) -> BitMap: ...
    def symmetric_difference_update(self, other: BitMap) -> None: ...
    def update(self, *all_values: Union[BitMap, List[int]]) -> None: ...
    def __and__(self, value: BitMap) -> BitMap: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, value: Any, /) -> bool: ...
    def __ge__(self, value: BitMap, /) -> bool: ...
    @overload
    def __getitem__(self, item: int, /) -> int: ...
    @overload
    def __getitem__(self, item: slice, /) -> BitMap: ...
    def getstate__(self) -> Any: ...
    def __gt__(self, value: BitMap, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __iand__(self, value: BitMap, /) -> None: ...
    def __ior__(self, value: BitMap, /) -> None: ...
    def __isub__(self, value: BitMap, /) -> None: ...
    def __iter__(self, /) -> Iterator[int]: ...
    def __ixor__(self, value: BitMap, /) -> None: ...
    def __le__(self, value: BitMap, /) -> bool: ...
    def __len__(self, /) -> int: ...
    def __lt__(self, value: BitMap, /) -> bool: ...
    def __ne__(self, value: Any, /) -> bool: ...
    def __or__(self, value: BitMap, /) -> BitMap: ...
    def __rand__(self, value: BitMap, /) -> BitMap: ...
    def __repr__(self) -> str: ...
    def __ror__(self, value: BitMap, /) -> BitMap: ...
    def __rxor__(self, value: BitMap, /) -> BitMap: ...
    def __setstate__(self, state: Any) -> None: ...
    def __sizeof__(self) -> int: ...
    def __str__(self, /) -> str: ...
    def __sub__(self, value: BitMap, /) -> BitMap: ...
    def __xor__(self, value: BitMap, /) -> BitMap: ...
    def contains_range(self, start: int, end: int) -> bool: ...
    def copy(self) -> BitMap: ...
    @staticmethod
    def difference(*bitmaps: BitMap) -> BitMap: ...
    def difference_cardinality(self, other: BitMap) -> int: ...
    def flip(self, start: int, end: int) -> BitMap: ...
    def get_statistics(self) -> Dict[str, int]: ...
    def intersect(self, other: BitMap) -> BitMap: ...
    @staticmethod
    def intersection(*bitmaps: BitMap) -> BitMap: ...
    @staticmethod
    def union(*bitmaps: BitMap) -> BitMap: ...
    @staticmethod
    def deserialize(buff: bytes) -> BitMap: ...
    def serialize(self) -> bytes: ...

class FrozenBitMap(BitMap):
    ...
